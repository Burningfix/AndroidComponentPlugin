apply plugin: 'com.android.application'
apply plugin: 'project-report'

android {
    compileSdkVersion rootProject.ext.android.compileSdkVersion
    buildToolsVersion rootProject.ext.android.buildToolsVersion

    defaultConfig {
        resConfigs "zh", "en"
        applicationId rootProject.ext.android.applicationId
        minSdkVersion rootProject.ext.android.minSdkVersion
        targetSdkVersion rootProject.ext.android.targetSdkVersion
        versionCode rootProject.ext.android.versionCode
        versionName rootProject.ext.android.versionName
        ndk {
            abiFilters 'armeabi-v7a', 'x86'
        }
    }

    //signing.properties在根目录
    def keystorePropertiesFile = rootProject.file("signing.properties")
    def keystoreProperties = new Properties()
    if (keystorePropertiesFile != null && keystorePropertiesFile.canRead()) {
        keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
    } else {
        println "==>请在根目录创建signing.properties文件"
        return
    }

    signingConfigs {
        release {
            v1SigningEnabled true
            v2SigningEnabled true
            if (keystorePropertiesFile != null && keystorePropertiesFile.canRead()) {
                String kAlias = keystoreProperties["KEY_ALIAS"]
                String kPwd = keystoreProperties["KEY_PASSWORD"]
                String sFile = keystoreProperties['STORE_FILE']
                String sPwd = keystoreProperties["STORE_PASSWORD"]
                if (kAlias != null && kPwd != null && sFile != null && sPwd != null) {
                    keyAlias keystoreProperties["KEY_ALIAS"]
                    keyPassword keystoreProperties["KEY_PASSWORD"]
                    //注意下面的file()，否则无法使用
                    storeFile file(keystoreProperties['STORE_FILE'])
                    storePassword keystoreProperties["STORE_PASSWORD"]
                } else {
                    println "==>请检查signing.properties文件中的四个属性是否为空"
                    return
                }
            } else {
                println "请在根目录创建signing.properties文件"
                return
            }
        }
        debug {
            v1SigningEnabled true
            v2SigningEnabled true
        }
    }

    packagingOptions {
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/DEPENDENCIES.txt'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/notice.txt'
        exclude 'META-INF/license.txt'
        exclude 'META-INF/dependencies.txt'
        exclude 'META-INF/LGPL2.1'
        exclude 'META-INF/ASL2.0'
        exclude 'META-INF/CERT.SF'
        exclude 'META-INF/CERT.RSA'
        exclude 'META-INF/MANIFEST.MF'
    }

    buildTypes {
        debug {
            debuggable true
            minifyEnabled false
            zipAlignEnabled false
            shrinkResources false
            crunchPngs false
        }
        release {
            debuggable false
            shrinkResources true
            zipAlignEnabled true
            minifyEnabled true
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation rootProject.ext.dependencies["androidx.appcompat"]
}

//https://dim.red/2018/02/05/android_dependency_analyse_code/
//因为 Gradle 的依赖发生冲突的时候, 会解决冲突, 默认是使用最高的版本,
// 但是也会因为 force 字段的关系选择较低的版本,我们往往需要知道打到APK里面依赖的具体版本.
project.getGradle().addBuildListener(new BuildListener() {

    @Override
    void buildStarted(Gradle gradle) {

    }

    @Override
    void settingsEvaluated(Settings settings) {

    }

    @Override
    void projectsLoaded(Gradle gradle) {

    }

    @Override
    void projectsEvaluated(Gradle gradle) {

    }

    @Override
    void buildFinished(BuildResult result) {
        project.android.applicationVariants.each { variant ->
            boolean executed = false
            //https://github.com/Meituan-Dianping/walle/issues/276#issuecomment-465843685
            if (variant.hasProperty('assembleProvider')) {
                variant.assembleProvider.get()
                executed = variant.assembleProvider.get().state.executed
            } else {
                executed = variant.assemble.state.executed
            }
            if (!executed) return
            if (this.gradle.gradleVersion >= "4.1") {
                // android plugin 3.0 以上
                def runtime = project.configurations.create("d_analyse" + variant.runtimeConfiguration.name)
                runtime.setCanBeConsumed(false)
                runtime.extendsFrom(variant.runtimeConfiguration)
                runtime.getAttributes().attribute(Attribute.of("artifactType", String.class), "jar")
                variant.runtimeConfiguration.getAttributes().keySet().forEach({
                    runtime.getAttributes().attribute(it, variant.runtimeConfiguration.getAttributes().getAttribute(it))
                })
                println("${variant.name}  analyse")
                println("runtime dependency ")
                println("------------------")
                runtime.resolvedConfiguration.resolvedArtifacts.forEach({
                    def id = it.moduleVersion.id
                    println(id.group + ":" + id.name + ":" + id.version)
                })
                println("------------------\n ")
                def packageC = project.configurations.create("d_analyse_" + variant.compileConfiguration.name)
                packageC.setCanBeConsumed(false)
                packageC.extendsFrom(variant.compileConfiguration)
                packageC.getAttributes().attribute(Attribute.of("artifactType", String.class), "jar")
                variant.compileConfiguration.getAttributes().keySet().forEach({
                    packageC.getAttributes().attribute(it, variant.compileConfiguration.getAttributes().getAttribute(it))
                })
                println("package dependency ")
                println("------------------")
                packageC.resolvedConfiguration.resolvedArtifacts.forEach({
                    def id = it.moduleVersion.id
                    println(id.group + ":" + id.name + ":" + id.version)
                })
                println("------------------\n ")
                println("\n ")
            }
        }
    }
})
